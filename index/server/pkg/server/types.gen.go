//
// Copyright 2023 Red Hat, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.11.0. **DO NOT EDIT**
package server

import (
	"encoding/json"
	"fmt"
)

// Defines values for DevfileMetadataArchitectures.
const (
	Amd64   DevfileMetadataArchitectures = "amd64"
	Arm64   DevfileMetadataArchitectures = "arm64"
	Ppc64le DevfileMetadataArchitectures = "ppc64le"
	S390x   DevfileMetadataArchitectures = "s390x"
)

// Devfile defines model for Devfile.
type Devfile struct {
	// Map of implementation-dependant free-form YAML attributes.
	Attributes *Devfile_Attributes `json:"attributes,omitempty"`

	// Predefined, ready-to-use, devworkspace-related commands
	Commands *[]interface{} `json:"commands,omitempty"`

	// List of the devworkspace components, such as editor and plugins, user-provided containers, or other types of components
	Components *[]interface{} `json:"components,omitempty"`

	// Bindings of commands to events. Each command is referred-to by its name.
	Events *struct {
		// IDs of commands that should be executed after the devworkspace is completely started. In the case of Che-Theia, these commands should be executed after all plugins and extensions have started, including project cloning. This means that those commands are not triggered until the user opens the IDE in his browser.
		PostStart *[]string `json:"postStart,omitempty"`

		// IDs of commands that should be executed after stopping the devworkspace.
		PostStop *[]string `json:"postStop,omitempty"`

		// IDs of commands that should be executed before the devworkspace start. Kubernetes-wise, these commands would typically be executed in init containers of the devworkspace POD.
		PreStart *[]string `json:"preStart,omitempty"`

		// IDs of commands that should be executed before stopping the devworkspace.
		PreStop *[]string `json:"preStop,omitempty"`
	} `json:"events,omitempty"`

	// Optional metadata
	Metadata *Devfile_Metadata `json:"metadata,omitempty"`

	// Parent devworkspace template
	Parent *interface{} `json:"parent,omitempty"`

	// Projects worked on in the devworkspace, containing names and sources locations
	Projects *[]interface{} `json:"projects,omitempty"`

	// Devfile schema version
	SchemaVersion string `json:"schemaVersion"`

	// StarterProjects is a project that can be used as a starting point when bootstrapping new projects
	StarterProjects *[]interface{} `json:"starterProjects,omitempty"`

	// Map of key-value variables used for string replacement in the devfile. Values can be referenced via {{variable-key}} to replace the corresponding value in string fields in the devfile. Replacement cannot be used for
	//
	//  - schemaVersion, metadata, parent source
	//
	//  - element identifiers, e.g. command id, component name, endpoint name, project name
	//
	//  - references to identifiers, e.g. in events, a command's component, container's volume mount name
	//
	//  - string enums, e.g. command group kind, endpoint exposure
	Variables *Devfile_Variables `json:"variables,omitempty"`
}

// Map of implementation-dependant free-form YAML attributes.
type Devfile_Attributes struct {
	AdditionalProperties map[string]interface{} `json:"-"`
}

// Architecture describes the architecture type
type DevfileMetadataArchitectures string

// Map of implementation-dependant free-form YAML attributes. Deprecated, use the top-level attributes field instead.
type Devfile_Metadata_Attributes struct {
	AdditionalProperties map[string]interface{} `json:"-"`
}

// Optional metadata
type Devfile_Metadata struct {
	// Optional list of processor architectures that the devfile supports, empty list suggests that the devfile can be used on any architecture
	Architectures *[]DevfileMetadataArchitectures `json:"architectures,omitempty"`

	// Map of implementation-dependant free-form YAML attributes. Deprecated, use the top-level attributes field instead.
	Attributes *Devfile_Metadata_Attributes `json:"attributes,omitempty"`

	// Optional devfile description
	Description *string `json:"description,omitempty"`

	// Optional devfile display name
	DisplayName *string `json:"displayName,omitempty"`

	// Optional devfile global memory limit
	GlobalMemoryLimit *string `json:"globalMemoryLimit,omitempty"`

	// Optional devfile icon, can be a URI or a relative path in the project
	Icon *string `json:"icon,omitempty"`

	// Optional devfile language
	Language *string `json:"language,omitempty"`

	// Optional devfile name
	Name *string `json:"name,omitempty"`

	// Optional devfile project type
	ProjectType *string `json:"projectType,omitempty"`

	// Optional devfile provider information
	Provider *string `json:"provider,omitempty"`

	// Optional link to a page that provides support information
	SupportUrl *string `json:"supportUrl,omitempty"`

	// Optional devfile tags
	Tags *[]string `json:"tags,omitempty"`

	// Optional semver-compatible version
	Version *string `json:"version,omitempty"`

	// Optional devfile website
	Website              *string                `json:"website,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// Map of key-value variables used for string replacement in the devfile. Values can be referenced via {{variable-key}} to replace the corresponding value in string fields in the devfile. Replacement cannot be used for
//
//  - schemaVersion, metadata, parent source
//
//  - element identifiers, e.g. command id, component name, endpoint name, project name
//
//  - references to identifiers, e.g. in events, a command's component, container's volume mount name
//
//  - string enums, e.g. command group kind, endpoint exposure
type Devfile_Variables struct {
	AdditionalProperties map[string]string `json:"-"`
}

// The index file schema
type Schema struct {
	// The description of devfile
	Description *string `json:"description,omitempty"`

	// The display name of devfile
	DisplayName *string `json:"displayName,omitempty"`

	// The project language that is used in the devfile
	Language *string `json:"language,omitempty"`

	// Links related to the devfile
	Links *map[string]interface{} `json:"links,omitempty"`

	// The stack name
	Name *string `json:"name,omitempty"`

	// The project framework that is used in the devfile
	ProjectType *string `json:"projectType,omitempty"`

	// The file resources that compose a devfile stack
	Resources *[]string `json:"resources,omitempty"`

	// The project templates that can be used in the devfile
	StarterProjects *[]string `json:"starterProjects,omitempty"`

	// The tags associated to devfile
	Tags *[]string `json:"tags,omitempty"`
}

// The V2 index file schema
type V2Schema struct {
	// The description of devfile
	Description *string `json:"description,omitempty"`

	// The display name of devfile
	DisplayName *string `json:"displayName,omitempty"`

	// The project language that is used in the devfile
	Language *string `json:"language,omitempty"`

	// Links related to the devfile
	Links *map[string]interface{} `json:"links,omitempty"`

	// The stack name
	Name *string `json:"name,omitempty"`

	// The project framework that is used in the devfile
	ProjectType *string `json:"projectType,omitempty"`

	// The file resources that compose a devfile stack
	Resources *[]string `json:"resources,omitempty"`

	// The project templates that can be used in the devfile
	StarterProjects *[]string `json:"starterProjects,omitempty"`

	// The tags associated to devfile
	Tags *[]string `json:"tags,omitempty"`

	// Versions of the stack
	Versions *[]struct {
		// Architectures used by the stack version
		Architectures *[]string `json:"architectures,omitempty"`

		// Default stack version
		Default *bool `json:"default,omitempty"`

		// Description of stack version
		Description *string `json:"description,omitempty"`

		// Stores the information of remote repositories
		Git *struct {
			// Name of remote git repository
			RemoteName *string `json:"remoteName,omitempty"`

			// Remote repositories
			Remotes *map[string]interface{} `json:"remotes,omitempty"`

			// Git repository branch, tag or commit identity
			Revision *string `json:"revision,omitempty"`

			// Subdirectory in remote git repository to clone
			SubDir *string `json:"subDir,omitempty"`

			// URL of remote git repository
			Url *string `json:"url,omitempty"`
		} `json:"git,omitempty"`

		// Icon used by stack version
		Icon *string `json:"icon,omitempty"`

		// Stack version links
		Links *map[string]interface{} `json:"links,omitempty"`

		// Stack version resource files
		Resources *[]string `json:"resources,omitempty"`

		// Stack devfile schema version
		SchemaVersion *string `json:"schemaVersion,omitempty"`

		// Stack version starter project names
		StarterProjects *[]string `json:"starterProjects,omitempty"`

		// Stack version topic tags
		Tags *[]string `json:"tags,omitempty"`

		// Stack version name
		Version *string `json:"version,omitempty"`
	} `json:"versions,omitempty"`
}

// Arch defines model for arch.
type Arch = []string

// Icon defines model for icon.
type Icon = string

// DevfileErrorResponse defines model for devfileErrorResponse.
type DevfileErrorResponse struct {
	Error  *string `json:"error,omitempty"`
	Status *string `json:"status,omitempty"`
}

// DevfileNotFoundResponse defines model for devfileNotFoundResponse.
type DevfileNotFoundResponse struct {
	Status *string `json:"status,omitempty"`
}

// DevfileResponse defines model for devfileResponse.
type DevfileResponse = Devfile

// HealthResponse defines model for healthResponse.
type HealthResponse struct {
	Message *string `json:"message,omitempty"`
}

// IndexResponse defines model for indexResponse.
type IndexResponse = []Schema

// V2IndexResponse defines model for v2IndexResponse.
type V2IndexResponse = []V2Schema

// ServeDevfileIndexV1Params defines parameters for ServeDevfileIndexV1.
type ServeDevfileIndexV1Params struct {
	// The icon type filter
	IconType *Icon `form:"icon,omitempty" json:"icon,omitempty"`

	// The target architecture filter
	Archs *Arch `form:"arch,omitempty" json:"arch,omitempty"`
}

// ServeDevfileIndexV1WithTypeParams defines parameters for ServeDevfileIndexV1WithType.
type ServeDevfileIndexV1WithTypeParams struct {
	// The icon type filter
	IconType *Icon `form:"icon,omitempty" json:"icon,omitempty"`

	// The target architecture filter
	Archs *Arch `form:"arch,omitempty" json:"arch,omitempty"`
}

// ServeDevfileIndexV2Params defines parameters for ServeDevfileIndexV2.
type ServeDevfileIndexV2Params struct {
	// The icon type filter
	IconType *Icon `form:"icon,omitempty" json:"icon,omitempty"`

	// The target architecture filter
	Archs *Arch `form:"arch,omitempty" json:"arch,omitempty"`
}

// ServeDevfileIndexV2WithTypeParams defines parameters for ServeDevfileIndexV2WithType.
type ServeDevfileIndexV2WithTypeParams struct {
	// The icon type filter
	IconType *Icon `form:"icon,omitempty" json:"icon,omitempty"`

	// The target architecture filter
	Archs *Arch `form:"arch,omitempty" json:"arch,omitempty"`
}

// Getter for additional properties for Devfile_Attributes. Returns the specified
// element and whether it was found
func (a Devfile_Attributes) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Devfile_Attributes
func (a *Devfile_Attributes) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Devfile_Attributes to handle AdditionalProperties
func (a *Devfile_Attributes) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Devfile_Attributes to handle AdditionalProperties
func (a Devfile_Attributes) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Devfile_Metadata_Attributes. Returns the specified
// element and whether it was found
func (a Devfile_Metadata_Attributes) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Devfile_Metadata_Attributes
func (a *Devfile_Metadata_Attributes) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Devfile_Metadata_Attributes to handle AdditionalProperties
func (a *Devfile_Metadata_Attributes) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Devfile_Metadata_Attributes to handle AdditionalProperties
func (a Devfile_Metadata_Attributes) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Devfile_Metadata. Returns the specified
// element and whether it was found
func (a Devfile_Metadata) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Devfile_Metadata
func (a *Devfile_Metadata) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Devfile_Metadata to handle AdditionalProperties
func (a *Devfile_Metadata) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["architectures"]; found {
		err = json.Unmarshal(raw, &a.Architectures)
		if err != nil {
			return fmt.Errorf("error reading 'architectures': %w", err)
		}
		delete(object, "architectures")
	}

	if raw, found := object["attributes"]; found {
		err = json.Unmarshal(raw, &a.Attributes)
		if err != nil {
			return fmt.Errorf("error reading 'attributes': %w", err)
		}
		delete(object, "attributes")
	}

	if raw, found := object["description"]; found {
		err = json.Unmarshal(raw, &a.Description)
		if err != nil {
			return fmt.Errorf("error reading 'description': %w", err)
		}
		delete(object, "description")
	}

	if raw, found := object["displayName"]; found {
		err = json.Unmarshal(raw, &a.DisplayName)
		if err != nil {
			return fmt.Errorf("error reading 'displayName': %w", err)
		}
		delete(object, "displayName")
	}

	if raw, found := object["globalMemoryLimit"]; found {
		err = json.Unmarshal(raw, &a.GlobalMemoryLimit)
		if err != nil {
			return fmt.Errorf("error reading 'globalMemoryLimit': %w", err)
		}
		delete(object, "globalMemoryLimit")
	}

	if raw, found := object["icon"]; found {
		err = json.Unmarshal(raw, &a.Icon)
		if err != nil {
			return fmt.Errorf("error reading 'icon': %w", err)
		}
		delete(object, "icon")
	}

	if raw, found := object["language"]; found {
		err = json.Unmarshal(raw, &a.Language)
		if err != nil {
			return fmt.Errorf("error reading 'language': %w", err)
		}
		delete(object, "language")
	}

	if raw, found := object["name"]; found {
		err = json.Unmarshal(raw, &a.Name)
		if err != nil {
			return fmt.Errorf("error reading 'name': %w", err)
		}
		delete(object, "name")
	}

	if raw, found := object["projectType"]; found {
		err = json.Unmarshal(raw, &a.ProjectType)
		if err != nil {
			return fmt.Errorf("error reading 'projectType': %w", err)
		}
		delete(object, "projectType")
	}

	if raw, found := object["provider"]; found {
		err = json.Unmarshal(raw, &a.Provider)
		if err != nil {
			return fmt.Errorf("error reading 'provider': %w", err)
		}
		delete(object, "provider")
	}

	if raw, found := object["supportUrl"]; found {
		err = json.Unmarshal(raw, &a.SupportUrl)
		if err != nil {
			return fmt.Errorf("error reading 'supportUrl': %w", err)
		}
		delete(object, "supportUrl")
	}

	if raw, found := object["tags"]; found {
		err = json.Unmarshal(raw, &a.Tags)
		if err != nil {
			return fmt.Errorf("error reading 'tags': %w", err)
		}
		delete(object, "tags")
	}

	if raw, found := object["version"]; found {
		err = json.Unmarshal(raw, &a.Version)
		if err != nil {
			return fmt.Errorf("error reading 'version': %w", err)
		}
		delete(object, "version")
	}

	if raw, found := object["website"]; found {
		err = json.Unmarshal(raw, &a.Website)
		if err != nil {
			return fmt.Errorf("error reading 'website': %w", err)
		}
		delete(object, "website")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Devfile_Metadata to handle AdditionalProperties
func (a Devfile_Metadata) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Architectures != nil {
		object["architectures"], err = json.Marshal(a.Architectures)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'architectures': %w", err)
		}
	}

	if a.Attributes != nil {
		object["attributes"], err = json.Marshal(a.Attributes)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'attributes': %w", err)
		}
	}

	if a.Description != nil {
		object["description"], err = json.Marshal(a.Description)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'description': %w", err)
		}
	}

	if a.DisplayName != nil {
		object["displayName"], err = json.Marshal(a.DisplayName)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'displayName': %w", err)
		}
	}

	if a.GlobalMemoryLimit != nil {
		object["globalMemoryLimit"], err = json.Marshal(a.GlobalMemoryLimit)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'globalMemoryLimit': %w", err)
		}
	}

	if a.Icon != nil {
		object["icon"], err = json.Marshal(a.Icon)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'icon': %w", err)
		}
	}

	if a.Language != nil {
		object["language"], err = json.Marshal(a.Language)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'language': %w", err)
		}
	}

	if a.Name != nil {
		object["name"], err = json.Marshal(a.Name)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'name': %w", err)
		}
	}

	if a.ProjectType != nil {
		object["projectType"], err = json.Marshal(a.ProjectType)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'projectType': %w", err)
		}
	}

	if a.Provider != nil {
		object["provider"], err = json.Marshal(a.Provider)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'provider': %w", err)
		}
	}

	if a.SupportUrl != nil {
		object["supportUrl"], err = json.Marshal(a.SupportUrl)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'supportUrl': %w", err)
		}
	}

	if a.Tags != nil {
		object["tags"], err = json.Marshal(a.Tags)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'tags': %w", err)
		}
	}

	if a.Version != nil {
		object["version"], err = json.Marshal(a.Version)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'version': %w", err)
		}
	}

	if a.Website != nil {
		object["website"], err = json.Marshal(a.Website)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'website': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Devfile_Variables. Returns the specified
// element and whether it was found
func (a Devfile_Variables) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Devfile_Variables
func (a *Devfile_Variables) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Devfile_Variables to handle AdditionalProperties
func (a *Devfile_Variables) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Devfile_Variables to handle AdditionalProperties
func (a Devfile_Variables) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}
